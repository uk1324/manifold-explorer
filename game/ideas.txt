Could have a CAS console.

Could have an argument into simplify that would record the domain of the expression. For example whenever there is a negative power it would assert that the base is nonzero.


https://people.eecs.berkeley.edu/~fateman/papers/y=z2w.pdf
We could give a symb olic If   answer along the lines of the
construction ab ove This is rarely useful unless a it collapses sub
stantially as a consequence of arithmetic andor logical simplication
and b the CAS is able to continue computation with conditional
expressions including for example adding and multiplying them in
verting them   etc This is a challenge but in some sense inevitable
if the answer to the questions of domain are not and cannot yet b e
known Although we ve written this out it do es not seem to war
rant rep etition

The symbolic differentiation of ln(x) -> 1/x has a larger domain than the original function. Technically 1/x is the derivative of ln(|x|). This can also be interpreted as the analytic continutation of the derivative of ln(x)

Also you can define one sided derivatives in the function is defined on a closed set.

let m = sin(x)**2 + cos(x)**2 - 1
mm^(-1) gets simplified to 1 by most systems. Which is a correct transformation on the domain the expression is defined that is on the empty set.

Are there any operations that produce incorrect results because of domains.
One example might be differentation. If the derivative is defined only on open sets the the derivative of a function defined on a closed set is undefined on the boundary.

In integration integrals might be different based on wether expressions are equal. For example
sin(nx) is not always -1/n cos(nx), because n can be zero. n could be replaced with m (where m has a different variable than x).

x^k when k = -1 is also wrong


Crimes and misdemeanors in the computer algebra trade https://math.unm.edu/~wester/cas/references/Stoutemyer.pdf

Also 
solving
sin(x) = a
doesn't just give
x = arcsin(a)

In sympy
Things like arcsin(sin(x)) don't get automatically simplified but when using solve for 
arcsin(sin(x)) it gives only [0]

TODO: Write the rewrite rules inside the functions implementing them


((-1)^2)^(1/2) = (1)^(1/2)
(-1)^(2 * (1/2)) = (-1)^1 = -1

a is real
(a^(1/2))^2 = (a^2)^(1/2)
because the expression a^(1/2) is only defined for non negative a

One issue with using domains for computation is that the numerical computation of a simplified form of the domain expression might evaluate to a different value. Then the function will be undefined at 2 points instead of one for example.

I guess if the function isn't too weird then the function would be undefined for a range of floating point numbers around the point.

Also you can have both x > 0 and x < 0 as the domain assumptions which are contradictory.
Is this really an issue. If you simplify an expression and it turns out to be undefined one some region then it still should be correct.

Another issue is the order of operations. If you have an expression like (x^2)^(1/2) x^(1/2) then if you simplify left to right you wont notice the domain is actually x > 0

For solving inequalitites the monoticity of functions can be used.

e^(ln(sin(x)^2 + cos(x)^2 - 1))
is evaluated as 0 by wolfram alpha
same for 
e^ln(0)
this might be because e^(-inf) = 0


If we are solving an equation then a simplification like canceling in (x-1)^2 / (x^2 - 1) is invalid, because it introduces erronous solutions. But this simplification is valid if we have a function which we are simplifying. Assuming the domain is noted.
This gives the difference between indeterminates and variables. And these objects have different semantics. In one case you are looking for an equivalence of equations and in the other for equality of expressions.
This distinction is also made in 
"Computer algebra and theorem proving" Clemens Ballarin
https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=da10d8aae2d41b98922a31a9f34fd299afb014f8

Integration by substitution using a function with a different domain that the integrated function will also break the domain of antiderivative. For example tangent half angle substitution.
https://en.wikipedia.org/wiki/Tangent_half-angle_substitution#Examples

If you cannot know if an expression is equal to zero then you can't use the euclidean algorithm for gcd, because it checks when was the last nonzero remainder. Which will give wrong results if the zero remainder is not detected.

Could have functions that can apply theorems instead of the ad hoc application of rules. Each step would be added to a list.

I guess using computer algebra that isn't fully correct is nice for just exploring and playing around.

You can still have algorithm that just type check if the input has some decision algorithm. For example have a gcd algorithm that takes a decision algorithm for a certain kind of expression as an input.

How should conditionals be simplified.

Writing dx/dx' prints ""internal error" in mathdf and prints an exception in console